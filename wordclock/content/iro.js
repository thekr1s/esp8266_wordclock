"HTTP/1.0 200 \r\n"
"Content-Type: text/javascript\r\n"
"Cache-Control: max-age=1\r\n"
"\r\n"
"(function (global, factory) {\r\n"
"  typeof exports === \'object\' && typeof module !== \'undefined\' ? module.exports = factory() :\r\n"
"  typeof define === \'function\' && define.amd ? define(factory) :\r\n"
"  (global = global || self, global.iro = factory());\r\n"
"}(this, function () { \'use strict\';\r\n"
"\r\n"
"  var n,u,t,i,r,o,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function s(n,l){for(var u in l){ n[u]=l[u]; }return n}function a(n){var l=n.parentNode;l&&l.removeChild(n);}function h(n,l,u){var t,i,r,o,f=arguments;if(l=s({},l),arguments.length>3){ for(u=[u],t=3;t<arguments.length;t++){ u.push(f[t]); } }if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps){ for(i in n.defaultProps){ void 0===l[i]&&(l[i]=n.defaultProps[i]); } }return o=l.key,null!=(r=l.ref)&&delete l.ref,null!=o&&delete l.key,v(n,l,o,r)}function v(l,u,t,i){var r={type:l,props:u,key:t,ref:i,__k:null,__p:null,__b:0,__e:null,l:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(r),r}function d(n){return n.children}function y(n){if(null==n||\"boolean\"==typeof n){ return null; }if(\"string\"==typeof n||\"number\"==typeof n){ return v(null,n,null,null); }if(null!=n.__e||null!=n.__c){var l=v(n.type,n.props,n.key,null);return l.__e=n.__e,l}return n}function m(n,l){this.props=n,this.context=l;}function w(n,l){if(null==l){ return n.__p?w(n.__p,n.__p.__k.indexOf(n)+1):null; }for(var u;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){ return u.__e; } }return \"function\"==typeof n.type?w(n):null}function g(n){var l,u;if(null!=(n=n.__p)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break} }return g(n)}}function k(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i!==n.debounceRendering)&&(i=n.debounceRendering,(n.debounceRendering||t)(_));}function _(){var n,l,t,i,r,o,f,e;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();){ n.__d&&(t=void 0,i=void 0,o=(r=(l=n).__v).__e,f=l.__P,e=l.u,l.u=!1,f&&(t=[],i=$(f,r,s({},r),l.__n,void 0!==f.ownerSVGElement,null,t,e,null==o?w(r):o),j(t,r),i!=o&&g(r))); }}function b(n,l,u,t,i,r,o,c,s){var h,v,p,d,y,m,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=r?r[0]:_?w(u,0):null),h=0,l.__k=x(l.__k,function(u){if(null!=u){if(u.__p=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type){ k[h]=void 0; }else { for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null;} }if(d=$(n,u,p=p||f,t,i,r,o,null,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[])).push(v,u.__c||d,u),null!=d){if(null==m&&(m=d),null!=u.l){ d=u.l,u.l=null; }else if(r==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n){ n.appendChild(d); }else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2){ if(y==d){ break n; } }n.insertBefore(d,c);}\"option\"==l.type&&(n.value=\"\");}c=d.nextSibling,\"function\"==typeof l.type&&(l.l=d);}}return h++,u}),l.__e=m,null!=r&&\"function\"!=typeof l.type){ for(h=r.length;h--;){ null!=r[h]&&a(r[h]); } }for(h=_;h--;){ null!=k[h]&&D(k[h],k[h]); }if(g){ for(h=0;h<g.length;h++){ A(g[h],g[++h],g[++h]); } }}function x(n,l,u){if(null==u&&(u=[]),null==n||\"boolean\"==typeof n){ l&&u.push(l(null)); }else if(Array.isArray(n)){ for(var t=0;t<n.length;t++){ x(n[t],l,u); } }else { u.push(l?l(y(n)):n); }return u}function C(n,l,u,t,i){var r;for(r in u){ r in l||N(n,r,null,u[r],t); }for(r in l){ i&&\"function\"!=typeof l[r]||\"value\"===r||\"checked\"===r||u[r]===l[r]||N(n,r,l[r],u[r],t); }}function P(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=\"number\"==typeof u&&!1===c.test(l)?u+\"px\":null==u?\"\":u;}function N(n,l,u,t,i){var r,o,f,e,c;if(\"key\"===(l=i?\"className\"===l?\"class\":l:\"class\"===l?\"className\":l)||\"children\"===l);else if(\"style\"===l){ if(r=n.style,\"string\"==typeof u){ r.cssText=u; }else{if(\"string\"==typeof t&&(r.cssText=\"\",t=null),t){ for(o in t){ u&&o in u||P(r,o,\"\"); } }if(u){ for(f in u){ t&&u[f]===t[f]||P(r,f,u[f]); } }} }else{ \"o\"===l[0]&&\"n\"===l[1]?(e=l!==(l=l.replace(/Capture$/,\"\")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,T,e),(n.t||(n.t={}))[l]=u):n.removeEventListener(l,T,e)):\"list\"!==l&&\"tagName\"!==l&&\"form\"!==l&&!i&&l in n?n[l]=null==u?\"\":u:\"function\"!=typeof u&&\"dangerouslySetInnerHTML\"!==l&&(l!==(l=l.replace(/^xlink:?/,\"\"))?null==u||!1===u?n.removeAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase()):n.setAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u)); }}function T(l){return this.t[l.type](n.event?n.event(l):l)}function $(l,u,t,i,r,o,f,e,c,a){var h,v,p,y,w,g,k,_,C,P,N=u.type;if(void 0!==u.constructor){ return null; }(h=n.__b)&&h(u);try{n:if(\"function\"==typeof N){if(_=u.props,C=(h=N.contextType)&&i[h.__c],P=h?C?C.props.value:h.__p:i,t.__c?k=(v=u.__c=t.__c).__p=v.__E:(\"prototype\"in N&&N.prototype.render?u.__c=v=new N(_,P):(u.__c=v=new m(_,P),v.constructor=N,v.render=H),C&&C.sub(v),v.props=_,v.state||(v.state={}),v.context=P,v.__n=i,p=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=N.getDerivedStateFromProps&&s(v.__s==v.state?v.__s=s({},v.__s):v.__s,N.getDerivedStateFromProps(_,v.__s)),p){ null==N.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&f.push(v); }else{if(null==N.getDerivedStateFromProps&&null==e&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(_,P),!e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(_,v.__s,P)){for(v.props=_,v.state=v.__s,v.__d=!1,v.__v=u,u.__e=null!=c?c!==t.__e?c:t.__e:null,u.__k=t.__k,h=0;h<u.__k.length;h++){ u.__k[h]&&(u.__k[h].__p=u); }break n}null!=v.componentWillUpdate&&v.componentWillUpdate(_,v.__s,P);}for(y=v.props,w=v.state,v.context=P,v.props=_,v.state=v.__s,(h=n.__r)&&h(u),v.__d=!1,v.__v=u,v.__P=l,h=v.render(v.props,v.state,v.context),u.__k=x(null!=h&&h.type==d&&null==h.key?h.props.children:h),null!=v.getChildContext&&(i=s(s({},i),v.getChildContext())),p||null==v.getSnapshotBeforeUpdate||(g=v.getSnapshotBeforeUpdate(y,w)),b(l,u,t,i,r,o,f,c,a),v.base=u.__e;h=v.__h.pop();){ v.__s&&(v.state=v.__s),h.call(v); }p||null==y||null==v.componentDidUpdate||v.componentDidUpdate(y,w,g),k&&(v.__E=v.__p=null);}else { u.__e=z(t.__e,u,t,i,r,o,f,a); }(h=n.diffed)&&h(u);}catch(l){n.__e(l,u,t);}return u.__e}function j(l,u){for(var t;t=l.pop();){ try{t.componentDidMount();}catch(l){n.__e(l,t.__v);} }n.__c&&n.__c(u);}function z(n,l,u,t,i,r,o,c){var s,a,h,v,p=u.props,d=l.props;if(i=\"svg\"===l.type||i,null==n&&null!=r){ for(s=0;s<r.length;s++){ if(null!=(a=r[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,r[s]=null;break} } }if(null==n){if(null===l.type){ return document.createTextNode(d); }n=i?document.createElementNS(\"http://www.w3.org/2000/svg\",l.type):document.createElement(l.type),r=null;}return null===l.type?p!==d&&(null!=r&&(r[r.indexOf(n)]=null),n.data=d):l!==u&&(null!=r&&(r=e.slice.call(n.childNodes)),h=(p=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,c||(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||\"\")),C(n,d,p,i,c),l.__k=l.props.children,v||b(n,l,u,t,\"foreignObject\"!==l.type&&i,r,o,f,c),c||(\"value\"in d&&void 0!==d.value&&d.value!==n.value&&(n.value=null==d.value?\"\":d.value),\"checked\"in d&&void 0!==d.checked&&d.checked!==n.checked&&(n.checked=d.checked))),n}function A(l,u,t){try{\"function\"==typeof l?l(u):l.current=u;}catch(l){n.__e(l,t);}}function D(l,u,t){var i,r,o;if(n.unmount&&n.unmount(l),(i=l.ref)&&A(i,null,u),t||\"function\"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.l=null,null!=(i=l.__c)){if(i.componentWillUnmount){ try{i.componentWillUnmount();}catch(l){n.__e(l,u);} }i.base=i.__P=null;}if(i=l.__k){ for(o=0;o<i.length;o++){ i[o]&&D(i[o],u,t); } }null!=r&&a(r);}function H(n,l,u){return this.constructor(n,u)}function I(l,u,t){var i,o,c;n.__p&&n.__p(l,u),o=(i=t===r)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],$(u,i?u.__k=l:(t||u).__k=l,o||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:o?null:e.slice.call(u.childNodes),c,!1,t||f,i),j(c,l);}n={},m.prototype.setState=function(n,l){var u=this.__s!==this.state&&this.__s||(this.__s=s({},this.state));(\"function\"!=typeof n||(n=n(u,this.props)))&&s(u,n),null!=n&&this.__v&&(this.u=!1,l&&this.__h.push(l),k(this));},m.prototype.forceUpdate=function(n){this.__v&&(n&&this.__h.push(n),this.u=!0,k(this));},m.prototype.render=d,u=[],t=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,i=n.debounceRendering,n.__e=function(n,l,u){for(var t;l=l.__p;){ if((t=l.__c)&&!t.__p){ try{if(t.constructor&&null!=t.constructor.getDerivedStateFromError){ t.setState(t.constructor.getDerivedStateFromError(n)); }else{if(null==t.componentDidCatch){ continue; }t.componentDidCatch(n);}return k(t.__E=t)}catch(l){n=l;} } }throw n},r=f,o=0;\r\n"
"\r\n"
"  // Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\r\n"
"  // https://github.com/bgrins/TinyColor\r\n"
"  // Kelvin temperature math borrowed from Neil Barlett\'s implementation\r\n"
"  // from https://github.com/neilbartlett/color-temperature\r\n"
"  // https://www.w3.org/TR/css3-values/#integers\r\n"
"  var CSS_INTEGER = \'[-\\\\+]?\\\\d+%?\'; // http://www.w3.org/TR/css3-values/#number-value\r\n"
"\r\n"
"  var CSS_NUMBER = \'[-\\\\+]?\\\\d*\\\\.\\\\d+%?\'; // Allow positive/negative integer/number. Don\'t capture the either/or, just the entire outcome\r\n"
"\r\n"
"  var CSS_UNIT = \'(?:\' + CSS_NUMBER + \')|(?:\' + CSS_INTEGER + \')\'; // Parse function params\r\n"
"  // Parens and commas are optional, and this also allows for whitespace between numbers\r\n"
"\r\n"
"  var PERMISSIVE_MATCH_3 = \'[\\\\s|\\\\(]+(\' + CSS_UNIT + \')[,|\\\\s]+(\' + CSS_UNIT + \')[,|\\\\s]+(\' + CSS_UNIT + \')\\\\s*\\\\)?\';\r\n"
"  var PERMISSIVE_MATCH_4 = \'[\\\\s|\\\\(]+(\' + CSS_UNIT + \')[,|\\\\s]+(\' + CSS_UNIT + \')[,|\\\\s]+(\' + CSS_UNIT + \')[,|\\\\s]+(\' + CSS_UNIT + \')\\\\s*\\\\)?\'; // Regex patterns for functional color strings\r\n"
"\r\n"
"  var REGEX_FUNCTIONAL_RGB = new RegExp(\'rgb\' + PERMISSIVE_MATCH_3);\r\n"
"  var REGEX_FUNCTIONAL_RGBA = new RegExp(\'rgba\' + PERMISSIVE_MATCH_4);\r\n"
"  var REGEX_FUNCTIONAL_HSL = new RegExp(\'hsl\' + PERMISSIVE_MATCH_3);\r\n"
"  var REGEX_FUNCTIONAL_HSLA = new RegExp(\'hsla\' + PERMISSIVE_MATCH_4); // Color string parsing regex\r\n"
"\r\n"
"  var HEX_START = \'^(?:#?|0x?)\';\r\n"
"  var HEX_INT_SINGLE = \'([0-9a-fA-F]{1})\';\r\n"
"  var HEX_INT_DOUBLE = \'([0-9a-fA-F]{2})\';\r\n"
"  var REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + \'$\');\r\n"
"  var REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + \'$\');\r\n"
"  var REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + \'$\');\r\n"
"  var REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + \'$\'); // Kelvin temperature bounds\r\n"
"\r\n"
"  var KELVIN_MIN = 1000;\r\n"
"  var KELVIN_MAX = 40000; // Math shorthands\r\n"
"\r\n"
"  var log = Math.log;\r\n"
"  var round = Math.round;\r\n"
"  var floor = Math.floor;\r\n"
"  /**\r\n"
"   * @desc Clamp a number between a min and max value\r\n"
"   * @param num - input value\r\n"
"   * @param min - min allowed value\r\n"
"   * @param max - max allowed value\r\n"
"   */\r\n"
"\r\n"
"  function clamp(num, min, max) {\r\n"
"    return Math.min(Math.max(num, min), max);\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Parse a css unit string - either regular int or a percentage number\r\n"
"   * @param str - css unit string\r\n"
"   * @param max - max unit value, used for calculating percentages\r\n"
"   */\r\n"
"\r\n"
"\r\n"
"  function parseUnit(str, max) {\r\n"
"    var isPercentage = str.indexOf(\'%\') > -1;\r\n"
"    var num = parseFloat(str);\r\n"
"    return isPercentage ? max / 100 * num : num;\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Parse hex str to an int\r\n"
"   * @param str - hex string to parse\r\n"
"   */\r\n"
"\r\n"
"\r\n"
"  function parseHexInt(str) {\r\n"
"    return parseInt(str, 16);\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Convert nunber into to 2-digit hex\r\n"
"   * @param int - number to convert\r\n"
"   */\r\n"
"\r\n"
"\r\n"
"  function intToHex(int) {\r\n"
"    return int.toString(16).padStart(2, \'0\');\r\n"
"  }\r\n"
"\r\n"
"  var IroColor = function IroColor(value, onChange) {\r\n"
"    // The default Color value\r\n"
"    this.$ = {\r\n"
"      h: 0,\r\n"
"      s: 0,\r\n"
"      v: 0,\r\n"
"      a: 1\r\n"
"    };\r\n"
"    if (value) { this.set(value); } // The watch callback function for this Color will be stored here\r\n"
"\r\n"
"    this.onChange = onChange;\r\n"
"    this.initialValue = Object.assign({}, this.$); // copy initial value\r\n"
"  };\r\n"
"\r\n"
"  var prototypeAccessors = { hsv: { configurable: true },hsva: { configurable: true },hue: { configurable: true },saturation: { configurable: true },value: { configurable: true },alpha: { configurable: true },kelvin: { configurable: true },red: { configurable: true },green: { configurable: true },blue: { configurable: true },rgb: { configurable: true },rgba: { configurable: true },hsl: { configurable: true },hsla: { configurable: true },rgbString: { configurable: true },rgbaString: { configurable: true },hexString: { configurable: true },hex8String: { configurable: true },hslString: { configurable: true },hslaString: { configurable: true } };\r\n"
"  /**\r\n"
"    * @desc Set the Color from any valid value\r\n"
"    * @param value - new color value\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.prototype.set = function set (value) {\r\n"
"    if (typeof value === \'string\') {\r\n"
"      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {\r\n"
"        this.hexString = value;\r\n"
"      } else if (/^rgba?/.test(value)) {\r\n"
"        this.rgbString = value;\r\n"
"      } else if (/^hsla?/.test(value)) {\r\n"
"        this.hslString = value;\r\n"
"      }\r\n"
"    } else if (typeof value === \'object\') {\r\n"
"      if (value instanceof IroColor) {\r\n"
"        this.hsv = value.hsv;\r\n"
"      } else if (typeof value === \'object\' && \'r\' in value && \'g\' in value && \'b\' in value) {\r\n"
"        this.rgb = value;\r\n"
"      } else if (typeof value === \'object\' && \'h\' in value && \'s\' in value && \'v\' in value) {\r\n"
"        this.hsv = value;\r\n"
"      } else if (typeof value === \'object\' && \'h\' in value && \'s\' in value && \'l\' in value) {\r\n"
"        this.hsl = value;\r\n"
"      }\r\n"
"    } else {\r\n"
"      throw new Error(\'Invalid color value\');\r\n"
"    }\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Shortcut to set a specific channel value\r\n"
"    * @param format - hsv | hsl | rgb\r\n"
"    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\r\n"
"    * @param value - new value for the channel\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.prototype.setChannel = function setChannel (format, channel, value) {\r\n"
"      var obj;\r\n"
"\r\n"
"    this[format] = Object.assign({}, this[format],\r\n"
"      ( obj = {}, obj[channel] = value, obj ));\r\n"
"  };\r\n"
"  /**\r\n"
"   * @desc Reset color back to its initial value\r\n"
"   */\r\n"
"\r\n"
"\r\n"
"  IroColor.prototype.reset = function reset () {\r\n"
"    this.hsva = this.initialValue;\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc make new Color instance with the same value as this one\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.prototype.clone = function clone () {\r\n"
"    return new IroColor(this);\r\n"
"  };\r\n"
"  /**\r\n"
"   * @desc remove color onChange\r\n"
"   */\r\n"
"\r\n"
"\r\n"
"  IroColor.prototype.unbind = function unbind () {\r\n"
"    this.onChange = undefined;\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Convert hsv object to rgb\r\n"
"    * @param hsv - hsv color object\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.hsvToRgb = function hsvToRgb (hsv) {\r\n"
"    var h = hsv.h / 60;\r\n"
"    var s = hsv.s / 100;\r\n"
"    var v = hsv.v / 100;\r\n"
"    var i = floor(h);\r\n"
"    var f = h - i;\r\n"
"    var p = v * (1 - s);\r\n"
"    var q = v * (1 - f * s);\r\n"
"    var t = v * (1 - (1 - f) * s);\r\n"
"    var mod = i % 6;\r\n"
"    var r = [v, q, p, p, t, v][mod];\r\n"
"    var g = [t, v, v, q, p, p][mod];\r\n"
"    var b = [p, p, t, v, v, q][mod];\r\n"
"    return {\r\n"
"      r: clamp(r * 255, 0, 255),\r\n"
"      g: clamp(g * 255, 0, 255),\r\n"
"      b: clamp(b * 255, 0, 255)\r\n"
"    };\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Convert rgb object to hsv\r\n"
"    * @param rgb - rgb object\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.rgbToHsv = function rgbToHsv (rgb) {\r\n"
"    var r = rgb.r / 255;\r\n"
"    var g = rgb.g / 255;\r\n"
"    var b = rgb.b / 255;\r\n"
"    var max = Math.max(r, g, b);\r\n"
"    var min = Math.min(r, g, b);\r\n"
"    var delta = max - min;\r\n"
"    var hue = 0;\r\n"
"    var value = max;\r\n"
"    var saturation = max === 0 ? 0 : delta / max;\r\n"
"\r\n"
"    switch (max) {\r\n"
"      case min:\r\n"
"        hue = 0; // achromatic\r\n"
"\r\n"
"        break;\r\n"
"\r\n"
"      case r:\r\n"
"        hue = (g - b) / delta + (g < b ? 6 : 0);\r\n"
"        break;\r\n"
"\r\n"
"      case g:\r\n"
"        hue = (b - r) / delta + 2;\r\n"
"        break;\r\n"
"\r\n"
"      case b:\r\n"
"        hue = (r - g) / delta + 4;\r\n"
"        break;\r\n"
"    }\r\n"
"\r\n"
"    return {\r\n"
"      h: hue * 60 % 360,\r\n"
"      s: clamp(saturation * 100, 0, 100),\r\n"
"      v: clamp(value * 100, 0, 100)\r\n"
"    };\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Convert hsv object to hsl\r\n"
"    * @param hsv - hsv object\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.hsvToHsl = function hsvToHsl (hsv) {\r\n"
"    var s = hsv.s / 100;\r\n"
"    var v = hsv.v / 100;\r\n"
"    var l = (2 - s) * v;\r\n"
"    var divisor = l <= 1 ? l : 2 - l; // Avoid division by zero when lightness is close to zero\r\n"
"\r\n"
"    var saturation = divisor < 1e-9 ? 0 : s * v / divisor;\r\n"
"    return {\r\n"
"      h: hsv.h,\r\n"
"      s: clamp(saturation * 100, 0, 100),\r\n"
"      l: clamp(l * 50, 0, 100)\r\n"
"    };\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Convert hsl object to hsv\r\n"
"    * @param hsl - hsl object\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.hslToHsv = function hslToHsv (hsl) {\r\n"
"    var l = hsl.l * 2;\r\n"
"    var s = hsl.s * (l <= 100 ? l : 200 - l) / 100; // Avoid division by zero when l + s is near 0\r\n"
"\r\n"
"    var saturation = l + s < 1e-9 ? 0 : 2 * s / (l + s);\r\n"
"    return {\r\n"
"      h: hsl.h,\r\n"
"      s: clamp(saturation * 100, 0, 100),\r\n"
"      v: clamp((l + s) / 2, 0, 100)\r\n"
"    };\r\n"
"  };\r\n"
"  /**\r\n"
"    * @desc Convert a kelvin temperature to an approx, RGB value\r\n"
"    * @param kelvin - kelvin temperature\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.kelvinToRgb = function kelvinToRgb (kelvin) {\r\n"
"    var temp = kelvin / 100;\r\n"
"    var r, g, b;\r\n"
"\r\n"
"    if (temp < 66) {\r\n"
"      r = 255;\r\n"
"      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\r\n"
"      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\r\n"
"    } else {\r\n"
"      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\r\n"
"      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\r\n"
"      b = 255;\r\n"
"    }\r\n"
"\r\n"
"    return {\r\n"
"      r: clamp(floor(r), 0, 255),\r\n"
"      g: clamp(floor(g), 0, 255),\r\n"
"      b: clamp(floor(b), 0, 255)\r\n"
"    };\r\n"
"  };\r\n"
"  /**\r\n"
"   * @desc Convert an RGB color to an approximate kelvin temperature\r\n"
"   * @param kelvin - kelvin temperature\r\n"
"  */\r\n"
"\r\n"
"\r\n"
"  IroColor.rgbToKelvin = function rgbToKelvin (rgb) {\r\n"
"    var r = rgb.r;\r\n"
"      var b = rgb.b;\r\n"
"    var eps = 0.4;\r\n"
"    var minTemp = KELVIN_MIN;\r\n"
"    var maxTemp = KELVIN_MAX;\r\n"
"    var temp;\r\n"
"\r\n"
"    while (maxTemp - minTemp > eps) {\r\n"
"      temp = (maxTemp + minTemp) * 0.5;\r\n"
"      var rgb$1 = IroColor.kelvinToRgb(temp);\r\n"
"\r\n"
"      if (rgb$1.b / rgb$1.r >= b / r) {\r\n"
"        maxTemp = temp;\r\n"
"      } else {\r\n"
"        minTemp = temp;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    return temp;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsv.get = function () {\r\n"
"    // value is cloned to allow changes to be made to the values before passing them back\r\n"
"    var value = this.$;\r\n"
"    return {\r\n"
"      h: value.h,\r\n"
"      s: value.s,\r\n"
"      v: value.v\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsv.set = function (newValue) {\r\n"
"    var oldValue = this.$;\r\n"
"    newValue = Object.assign({}, oldValue,\r\n"
"      newValue); // If this Color is being watched for changes we need to compare the new and old values to check the difference\r\n"
"    // Otherwise we can just be lazy\r\n"
"\r\n"
"    if (this.onChange) {\r\n"
"      // Compute changed values\r\n"
"      var changes = {\r\n"
"        h: false,\r\n"
"        v: false,\r\n"
"        s: false,\r\n"
"        a: false\r\n"
"      };\r\n"
"\r\n"
"      for (var key in oldValue) {\r\n"
"        changes[key] = newValue[key] != oldValue[key];\r\n"
"      }\r\n"
"\r\n"
"      this.$ = newValue; // If the value has changed, call hook callback\r\n"
"\r\n"
"      if (changes.h || changes.s || changes.v || changes.a) { this.onChange(this, changes); }\r\n"
"    } else {\r\n"
"      this.$ = newValue;\r\n"
"    }\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsva.get = function () {\r\n"
"    return Object.assign({}, this.$);\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsva.set = function (value) {\r\n"
"    this.hsv = value;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hue.get = function () {\r\n"
"    return this.$.h;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hue.set = function (value) {\r\n"
"    this.hsv = {\r\n"
"      h: value\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.saturation.get = function () {\r\n"
"    return this.$.s;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.saturation.set = function (value) {\r\n"
"    this.hsv = {\r\n"
"      s: value\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.value.get = function () {\r\n"
"    return this.$.v;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.value.set = function (value) {\r\n"
"    this.hsv = {\r\n"
"      v: value\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.alpha.get = function () {\r\n"
"    return this.$.a;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.alpha.set = function (value) {\r\n"
"    this.hsv = Object.assign({}, this.hsv,\r\n"
"      {a: value});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.kelvin.get = function () {\r\n"
"    return IroColor.rgbToKelvin(this.rgb);\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.kelvin.set = function (value) {\r\n"
"    this.rgb = IroColor.kelvinToRgb(value);\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.red.get = function () {\r\n"
"    var rgb = this.rgb;\r\n"
"    return rgb.r;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.red.set = function (value) {\r\n"
"    this.rgb = Object.assign({}, this.rgb,\r\n"
"      {r: value});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.green.get = function () {\r\n"
"    var rgb = this.rgb;\r\n"
"    return rgb.g;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.green.set = function (value) {\r\n"
"    this.rgb = Object.assign({}, this.rgb,\r\n"
"      {g: value});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.blue.get = function () {\r\n"
"    var rgb = this.rgb;\r\n"
"    return rgb.b;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.blue.set = function (value) {\r\n"
"    this.rgb = Object.assign({}, this.rgb,\r\n"
"      {b: value});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgb.get = function () {\r\n"
"    var ref = IroColor.hsvToRgb(this.$);\r\n"
"      var r = ref.r;\r\n"
"      var g = ref.g;\r\n"
"      var b = ref.b;\r\n"
"    return {\r\n"
"      r: round(r),\r\n"
"      g: round(g),\r\n"
"      b: round(b)\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgb.set = function (value) {\r\n"
"    this.hsv = Object.assign({}, IroColor.rgbToHsv(value),\r\n"
"      {a: value.a === undefined ? 1 : value.a});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgba.get = function () {\r\n"
"    return Object.assign({}, this.rgb,\r\n"
"      {a: this.alpha});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgba.set = function (value) {\r\n"
"    this.rgb = value;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsl.get = function () {\r\n"
"    var ref = IroColor.hsvToHsl(this.$);\r\n"
"      var h = ref.h;\r\n"
"      var s = ref.s;\r\n"
"      var l = ref.l;\r\n"
"    return {\r\n"
"      h: round(h),\r\n"
"      s: round(s),\r\n"
"      l: round(l)\r\n"
"    };\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsl.set = function (value) {\r\n"
"    this.hsv = Object.assign({}, IroColor.hslToHsv(value),\r\n"
"      {a: value.a === undefined ? 1 : value.a});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsla.get = function () {\r\n"
"    return Object.assign({}, this.hsl,\r\n"
"      {a: this.alpha});\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hsla.set = function (value) {\r\n"
"    this.hsl = value;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgbString.get = function () {\r\n"
"    var rgb = this.rgb;\r\n"
"    return (\"rgb(\" + (rgb.r) + \", \" + (rgb.g) + \", \" + (rgb.b) + \")\");\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgbString.set = function (value) {\r\n"
"    var match;\r\n"
"    var r,\r\n"
"        g,\r\n"
"        b,\r\n"
"        a = 1;\r\n"
"\r\n"
"    if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\r\n"
"      r = parseUnit(match[1], 255);\r\n"
"      g = parseUnit(match[2], 255);\r\n"
"      b = parseUnit(match[3], 255);\r\n"
"    } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\r\n"
"      r = parseUnit(match[1], 255);\r\n"
"      g = parseUnit(match[2], 255);\r\n"
"      b = parseUnit(match[3], 255);\r\n"
"      a = parseUnit(match[4], 1);\r\n"
"    }\r\n"
"\r\n"
"    if (match) {\r\n"
"      this.rgb = {\r\n"
"        r: r,\r\n"
"        g: g,\r\n"
"        b: b,\r\n"
"        a: a\r\n"
"      };\r\n"
"    } else {\r\n"
"      throw new Error(\'Invalid rgb string\');\r\n"
"    }\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgbaString.get = function () {\r\n"
"    var rgba = this.rgba;\r\n"
"    return (\"rgba(\" + (rgba.r) + \", \" + (rgba.g) + \", \" + (rgba.b) + \", \" + (rgba.a) + \")\");\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.rgbaString.set = function (value) {\r\n"
"    this.rgbString = value;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hexString.get = function () {\r\n"
"    var rgb = this.rgb;\r\n"
"    return (\"#\" + (intToHex(rgb.r)) + (intToHex(rgb.g)) + (intToHex(rgb.b)));\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hexString.set = function (value) {\r\n"
"    var match;\r\n"
"    var r,\r\n"
"        g,\r\n"
"        b,\r\n"
"        a = 255;\r\n"
"\r\n"
"    if (match = REGEX_HEX_3.exec(value)) {\r\n"
"      r = parseHexInt(match[1]) * 17;\r\n"
"      g = parseHexInt(match[2]) * 17;\r\n"
"      b = parseHexInt(match[3]) * 17;\r\n"
"    } else if (match = REGEX_HEX_4.exec(value)) {\r\n"
"      r = parseHexInt(match[1]) * 17;\r\n"
"      g = parseHexInt(match[2]) * 17;\r\n"
"      b = parseHexInt(match[3]) * 17;\r\n"
"      a = parseHexInt(match[4]) * 17;\r\n"
"    } else if (match = REGEX_HEX_6.exec(value)) {\r\n"
"      r = parseHexInt(match[1]);\r\n"
"      g = parseHexInt(match[2]);\r\n"
"      b = parseHexInt(match[3]);\r\n"
"    } else if (match = REGEX_HEX_8.exec(value)) {\r\n"
"      r = parseHexInt(match[1]);\r\n"
"      g = parseHexInt(match[2]);\r\n"
"      b = parseHexInt(match[3]);\r\n"
"      a = parseHexInt(match[4]);\r\n"
"    }\r\n"
"\r\n"
"    if (match) {\r\n"
"      this.rgb = {\r\n"
"        r: r,\r\n"
"        g: g,\r\n"
"        b: b,\r\n"
"        a: a / 255\r\n"
"      };\r\n"
"    } else {\r\n"
"      throw new Error(\'Invalid hex string\');\r\n"
"    }\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hex8String.get = function () {\r\n"
"    var rgba = this.rgba;\r\n"
"    return (\"#\" + (intToHex(rgba.r)) + (intToHex(rgba.g)) + (intToHex(rgba.b)) + (intToHex(floor(rgba.a * 255))));\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hex8String.set = function (value) {\r\n"
"    this.hexString = value;\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hslString.get = function () {\r\n"
"    var hsl = this.hsl;\r\n"
"    return (\"hsl(\" + (hsl.h) + \", \" + (hsl.s) + \"%, \" + (hsl.l) + \"%)\");\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hslString.set = function (value) {\r\n"
"    var match;\r\n"
"    var h,\r\n"
"        s,\r\n"
"        l,\r\n"
"        a = 1;\r\n"
"\r\n"
"    if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\r\n"
"      h = parseUnit(match[1], 360);\r\n"
"      s = parseUnit(match[2], 100);\r\n"
"      l = parseUnit(match[3], 100);\r\n"
"    } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\r\n"
"      h = parseUnit(match[1], 360);\r\n"
"      s = parseUnit(match[2], 100);\r\n"
"      l = parseUnit(match[3], 100);\r\n"
"      a = parseUnit(match[4], 1);\r\n"
"    }\r\n"
"\r\n"
"    if (match) {\r\n"
"      this.hsl = {\r\n"
"        h: h,\r\n"
"        s: s,\r\n"
"        l: l,\r\n"
"        a: a\r\n"
"      };\r\n"
"    } else {\r\n"
"      throw new Error(\'Invalid hsl string\');\r\n"
"    }\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hslaString.get = function () {\r\n"
"    var hsla = this.hsla;\r\n"
"    return (\"hsl(\" + (hsla.h) + \", \" + (hsla.s) + \"%, \" + (hsla.l) + \"%, \" + (hsla.a) + \")\");\r\n"
"  };\r\n"
"\r\n"
"  prototypeAccessors.hslaString.set = function (value) {\r\n"
"    this.hslString = value;\r\n"
"  };\r\n"
"\r\n"
"  Object.defineProperties( IroColor.prototype, prototypeAccessors );\r\n"
"\r\n"
"  var sliderDefaultOptions = {\r\n"
"    sliderShape: \'bar\',\r\n"
"    sliderType: \'value\',\r\n"
"    minTemperature: 2200,\r\n"
"    maxTemperature: 11000\r\n"
"  };\r\n"
"  /**\r\n"
"   * @desc Get the bounding dimensions of the slider\r\n"
"   * @param props - slider props\r\n"
"   */\r\n"
"\r\n"
"  function getSliderDimensions(props) {\r\n"
"    var width = props.width;\r\n"
"    var sliderSize = props.sliderSize;\r\n"
"    var borderWidth = props.borderWidth;\r\n"
"    var handleRadius = props.handleRadius;\r\n"
"    var padding = props.padding;\r\n"
"    var sliderShape = props.sliderShape;\r\n"
"    var ishorizontal = props.layoutDirection === \'horizontal\'; // automatically calculate sliderSize if its not defined\r\n"
"\r\n"
"    sliderSize = sliderSize ? sliderSize : padding * 2 + handleRadius * 2 + borderWidth * 2;\r\n"
"\r\n"
"    if (sliderShape === \'circle\') {\r\n"
"      return {\r\n"
"        handleStart: props.padding + props.handleRadius,\r\n"
"        handleRange: width - padding * 2 - handleRadius * 2 - borderWidth * 2,\r\n"
"        width: width,\r\n"
"        height: width,\r\n"
"        cx: width / 2,\r\n"
"        cy: width / 2,\r\n"
"        radius: width / 2 - borderWidth / 2\r\n"
"      };\r\n"
"    } else {\r\n"
"      return {\r\n"
"        handleStart: sliderSize / 2,\r\n"
"        handleRange: width - sliderSize,\r\n"
"        radius: sliderSize / 2,\r\n"
"        x: 0,\r\n"
"        y: 0,\r\n"
"        width: ishorizontal ? sliderSize : width,\r\n"
"        height: ishorizontal ? width : sliderSize\r\n"
"      };\r\n"
"    }\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current slider value for a given color, as a percentage\r\n"
"   * @param props - slider props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getCurrentSliderValue(props, color) {\r\n"
"    var hsva = color.hsva;\r\n"
"    var rgb = color.rgb;\r\n"
"\r\n"
"    switch (props.sliderType) {\r\n"
"      case \'red\':\r\n"
"        return rgb.r / 2.55;\r\n"
"\r\n"
"      case \'green\':\r\n"
"        return rgb.g / 2.55;\r\n"
"\r\n"
"      case \'blue\':\r\n"
"        return rgb.b / 2.55;\r\n"
"\r\n"
"      case \'alpha\':\r\n"
"        return hsva.a * 100;\r\n"
"\r\n"
"      case \'kelvin\':\r\n"
"        var minTemperature = props.minTemperature;\r\n"
"    var maxTemperature = props.maxTemperature;\r\n"
"        var temperatureRange = maxTemperature - minTemperature;\r\n"
"        var percent = (color.kelvin - minTemperature) / temperatureRange * 100; // clmap percentage\r\n"
"\r\n"
"        return Math.max(0, Math.min(percent, 100));\r\n"
"\r\n"
"      case \'hue\':\r\n"
"        return hsva.h /= 3.6;\r\n"
"\r\n"
"      case \'saturation\':\r\n"
"        return hsva.s;\r\n"
"\r\n"
"      case \'value\':\r\n"
"      default:\r\n"
"        return hsva.v;\r\n"
"    }\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current slider value from user input\r\n"
"   * @param props - slider props\r\n"
"   * @param x - global input x position\r\n"
"   * @param y - global input y position\r\n"
"   */\r\n"
"\r\n"
"  function getSliderValueFromInput(props, x, y) {\r\n"
"    var ref = getSliderDimensions(props);\r\n"
"    var handleRange = ref.handleRange;\r\n"
"    var handleStart = ref.handleStart;\r\n"
"    var handlePos;\r\n"
"\r\n"
"    if (props.layoutDirection === \'horizontal\') {\r\n"
"      handlePos = -1 * y + handleRange + handleStart;\r\n"
"    } else {\r\n"
"      handlePos = x - handleStart;\r\n"
"    } // clamp handle position\r\n"
"\r\n"
"\r\n"
"    handlePos = Math.max(Math.min(handlePos, handleRange), 0);\r\n"
"    var percent = Math.round(100 / handleRange * handlePos);\r\n"
"\r\n"
"    switch (props.sliderType) {\r\n"
"      case \'kelvin\':\r\n"
"        var minTemperature = props.minTemperature;\r\n"
"    var maxTemperature = props.maxTemperature;\r\n"
"        var temperatureRange = maxTemperature - minTemperature;\r\n"
"        return minTemperature + temperatureRange * (percent / 100);\r\n"
"\r\n"
"      case \'alpha\':\r\n"
"        return percent / 100;\r\n"
"\r\n"
"      case \'hue\':\r\n"
"        return percent * 3.6;\r\n"
"\r\n"
"      case \'red\':\r\n"
"      case \'blue\':\r\n"
"      case \'green\':\r\n"
"        return percent * 2.55;\r\n"
"\r\n"
"      default:\r\n"
"        return percent;\r\n"
"    }\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current handle position for a given color\r\n"
"   * @param props - slider props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getSliderHandlePosition(props, color) {\r\n"
"    var ref = getSliderDimensions(props);\r\n"
"    var width = ref.width;\r\n"
"    var height = ref.height;\r\n"
"    var handleRange = ref.handleRange;\r\n"
"    var handleStart = ref.handleStart;\r\n"
"    var ishorizontal = props.layoutDirection === \'horizontal\';\r\n"
"    var sliderValue = getCurrentSliderValue(props, color);\r\n"
"    var midPoint = ishorizontal ? width / 2 : height / 2;\r\n"
"    var handlePos = handleStart + sliderValue / 100 * handleRange;\r\n"
"\r\n"
"    if (ishorizontal) {\r\n"
"      handlePos = -1 * handlePos + handleRange + handleStart * 2;\r\n"
"    }\r\n"
"\r\n"
"    return {\r\n"
"      x: ishorizontal ? midPoint : handlePos,\r\n"
"      y: ishorizontal ? handlePos : midPoint\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the gradient stops for a slider\r\n"
"   * @param props - slider props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getSliderGradient(props, color) {\r\n"
"    var hsv = color.hsv;\r\n"
"    var rgb = color.rgb;\r\n"
"\r\n"
"    switch (props.sliderType) {\r\n"
"      case \'red\':\r\n"
"        return [[0, (\"rgb(\" + (0) + \",\" + (rgb.g) + \",\" + (rgb.b) + \")\")], [100, (\"rgb(\" + (255) + \",\" + (rgb.g) + \",\" + (rgb.b) + \")\")]];\r\n"
"\r\n"
"      case \'green\':\r\n"
"        return [[0, (\"rgb(\" + (rgb.r) + \",\" + (0) + \",\" + (rgb.b) + \")\")], [100, (\"rgb(\" + (rgb.r) + \",\" + (255) + \",\" + (rgb.b) + \")\")]];\r\n"
"\r\n"
"      case \'blue\':\r\n"
"        return [[0, (\"rgb(\" + (rgb.r) + \",\" + (rgb.g) + \",\" + (0) + \")\")], [100, (\"rgb(\" + (rgb.r) + \",\" + (rgb.g) + \",\" + (255) + \")\")]];\r\n"
"\r\n"
"      case \'alpha\':\r\n"
"        return [[0, (\"rgba(\" + (rgb.r) + \",\" + (rgb.g) + \",\" + (rgb.b) + \",0)\")], [100, (\"rgb(\" + (rgb.r) + \",\" + (rgb.g) + \",\" + (rgb.b) + \")\")]];\r\n"
"\r\n"
"      case \'kelvin\':\r\n"
"        var stops = [];\r\n"
"        var min = props.minTemperature;\r\n"
"        var max = props.maxTemperature;\r\n"
"        var numStops = 8;\r\n"
"        var range = max - min;\r\n"
"\r\n"
"        for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\r\n"
"          var ref = IroColor.kelvinToRgb(kelvin);\r\n"
"          var r = ref.r;\r\n"
"          var g = ref.g;\r\n"
"          var b = ref.b;\r\n"
"          stops.push([100 / numStops * stop, (\"rgb(\" + r + \",\" + g + \",\" + b + \")\")]);\r\n"
"        }\r\n"
"\r\n"
"        return stops;\r\n"
"\r\n"
"      case \'hue\':\r\n"
"        return [[0, \'#f00\'], [16.666, \'#ff0\'], [33.333, \'#0f0\'], [50, \'#0ff\'], [66.666, \'#00f\'], [83.333, \'#f0f\'], [100, \'#f00\']];\r\n"
"\r\n"
"      case \'saturation\':\r\n"
"        var noSat = IroColor.hsvToHsl({\r\n"
"          h: hsv.h,\r\n"
"          s: 0,\r\n"
"          v: hsv.v\r\n"
"        });\r\n"
"        var fullSat = IroColor.hsvToHsl({\r\n"
"          h: hsv.h,\r\n"
"          s: 100,\r\n"
"          v: hsv.v\r\n"
"        });\r\n"
"        return [[0, (\"hsl(\" + (noSat.h) + \",\" + (noSat.s) + \"%,\" + (noSat.l) + \"%)\")], [100, (\"hsl(\" + (fullSat.h) + \",\" + (fullSat.s) + \"%,\" + (fullSat.l) + \"%)\")]];\r\n"
"\r\n"
"      case \'value\':\r\n"
"      default:\r\n"
"        var hsl = IroColor.hsvToHsl({\r\n"
"          h: hsv.h,\r\n"
"          s: hsv.s,\r\n"
"          v: 100\r\n"
"        });\r\n"
"        return [[0, \'#000\'], [100, (\"hsl(\" + (hsl.h) + \",\" + (hsl.s) + \"%,\" + (hsl.l) + \"%)\")]];\r\n"
"    }\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the gradient coords for a slider\r\n"
"   * @param props - slider props\r\n"
"   */\r\n"
"\r\n"
"  function getSliderGradientCoords(props) {\r\n"
"    var ishorizontal = props.layoutDirection === \'horizontal\';\r\n"
"    return {\r\n"
"      x1: \'0%\',\r\n"
"      y1: ishorizontal ? \'100%\' : \'0%\',\r\n"
"      x2: ishorizontal ? \'0%\' : \'100%\',\r\n"
"      y2: \'0%\'\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  /**\r\n"
"   * @desc Get the point as the center of the wheel\r\n"
"   * @param props - wheel props\r\n"
"   */\r\n"
"  function getWheelDimensions(props) {\r\n"
"    var rad = props.width / 2;\r\n"
"    return {\r\n"
"      width: props.width,\r\n"
"      radius: rad - props.borderWidth,\r\n"
"      cx: rad,\r\n"
"      cy: rad\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Translate an angle according to wheelAngle and wheelDirection\r\n"
"   * @param props - wheel props\r\n"
"   * @param angle - input angle\r\n"
"   */\r\n"
"\r\n"
"  function translateWheelAngle(props, angle, invert) {\r\n"
"    var wheelAngle = props.wheelAngle;\r\n"
"    var wheelDirection = props.wheelDirection;\r\n"
"\r\n"
"    if (!invert && wheelDirection === \'clockwise\' || invert && wheelDirection === \'anticlockwise\') {\r\n"
"      angle = (invert ? 180 : 360) - (wheelAngle - angle);\r\n"
"    } else {\r\n"
"      angle = wheelAngle + angle;\r\n"
"    } // javascript\'s modulo operator doesn\'t produce positive numbers with negative input\r\n"
"    // https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\r\n"
"\r\n"
"\r\n"
"    return (angle % 360 + 360) % 360;\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current handle position for a given color\r\n"
"   * @param props - wheel props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getWheelHandlePosition(props, color) {\r\n"
"    var hsv = color.hsv;\r\n"
"    var ref = getWheelDimensions(props);\r\n"
"    var cx = ref.cx;\r\n"
"    var cy = ref.cy;\r\n"
"    var handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\r\n"
"    var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (Math.PI / 180);\r\n"
"    var handleDist = hsv.s / 100 * handleRange;\r\n"
"    var direction = props.wheelDirection === \'clockwise\' ? -1 : 1;\r\n"
"    return {\r\n"
"      x: cx + handleDist * Math.cos(handleAngle) * direction,\r\n"
"      y: cy + handleDist * Math.sin(handleAngle) * direction\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current wheel value from user input\r\n"
"   * @param props - wheel props\r\n"
"   * @param x - global input x position\r\n"
"   * @param y - global input y position\r\n"
"   */\r\n"
"\r\n"
"  function getWheelValueFromInput(props, x, y) {\r\n"
"    var ref = getWheelDimensions(props);\r\n"
"    var cx = ref.cx;\r\n"
"    var cy = ref.cy;\r\n"
"    var handleRange = props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\r\n"
"    x = cx - x;\r\n"
"    y = cy - y; // Calculate the hue by converting the angle to radians\r\n"
"\r\n"
"    var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (180 / Math.PI)); // Find the point\'s distance from the center of the wheel\r\n"
"    // This is used to show the saturation level\r\n"
"\r\n"
"    var handleDist = Math.min(Math.sqrt(x * x + y * y), handleRange);\r\n"
"    return {\r\n"
"      h: Math.round(hue),\r\n"
"      s: Math.round(100 / handleRange * handleDist)\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the bounding dimensions of the box\r\n"
"   * @param props - box props\r\n"
"   */\r\n"
"\r\n"
"  function getBoxDimensions(props) {\r\n"
"    var width = props.width;\r\n"
"    var padding = props.padding;\r\n"
"    var handleRadius = props.handleRadius;\r\n"
"    return {\r\n"
"      width: width,\r\n"
"      height: width,\r\n"
"      radius: padding + handleRadius\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current box value from user input\r\n"
"   * @param props - box props\r\n"
"   * @param x - global input x position\r\n"
"   * @param y - global input y position\r\n"
"   */\r\n"
"\r\n"
"  function getBoxValueFromInput(props, x, y) {\r\n"
"    var ref = getBoxDimensions(props);\r\n"
"    var width = ref.width;\r\n"
"    var height = ref.height;\r\n"
"    var radius = ref.radius;\r\n"
"    var handleStart = radius;\r\n"
"    var handleRangeX = width - radius * 2;\r\n"
"    var handleRangeY = height - radius * 2;\r\n"
"    var percentX = (x - handleStart) / handleRangeX * 100;\r\n"
"    var percentY = (y - handleStart) / handleRangeY * 100;\r\n"
"    return {\r\n"
"      s: Math.max(0, Math.min(percentX, 100)),\r\n"
"      v: Math.max(0, Math.min(100 - percentY, 100))\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the current box handle position for a given color\r\n"
"   * @param props - box props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getBoxHandlePosition(props, color) {\r\n"
"    var ref = getBoxDimensions(props);\r\n"
"    var width = ref.width;\r\n"
"    var height = ref.height;\r\n"
"    var radius = ref.radius;\r\n"
"    var hsv = color.hsv;\r\n"
"    var handleStart = radius;\r\n"
"    var handleRangeX = width - radius * 2;\r\n"
"    var handleRangeY = height - radius * 2;\r\n"
"    return {\r\n"
"      x: handleStart + hsv.s / 100 * handleRangeX,\r\n"
"      y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)\r\n"
"    };\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the gradient stops for a box\r\n"
"   * @param props - box props\r\n"
"   * @param color\r\n"
"   */\r\n"
"\r\n"
"  function getBoxGradients(props, color) {\r\n"
"    var hue = color.hue;\r\n"
"    return [// saturation gradient\r\n"
"    [[0, \'#fff\'], [100, (\"hsl(\" + hue + \",100%,50%)\")]], // lightness gradient\r\n"
"    [[0, \'rgba(0,0,0,0)\'], [100, \'#000\']]];\r\n"
"  }\r\n"
"\r\n"
"  // Keep track of html <base> elements for resolveSvgUrl\r\n"
"  // getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\r\n"
"  // So it only needs to be called once\r\n"
"  var BASE_ELEMENTS = document.getElementsByTagName(\'base\');\r\n"
"  /**\r\n"
"   * @desc Resolve an SVG reference URL\r\n"
"   * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\r\n"
"   * If a page is using a client-side routing library which makes use of the HTML <base> tag,\r\n"
"   * Safari won\'t be able to render SVG gradients properly (as they are referenced by URLs)\r\n"
"   * More info on the problem:\r\n"
"   * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\r\n"
"   * https://github.com/jaames/iro.js/issues/18\r\n"
"   * https://github.com/jaames/iro.js/issues/45\r\n"
"   * https://github.com/jaames/iro.js/pull/89\r\n"
"   * @props url - SVG reference URL\r\n"
"   */\r\n"
"\r\n"
"  function resolveSvgUrl(url) {\r\n"
"    // Sniff useragent string to check if the user is running Safari\r\n"
"    var ua = window.navigator.userAgent;\r\n"
"    var isSafari = /^((?!chrome|android).)*safari/i.test(ua);\r\n"
"    var isIos = /iPhone|iPod|iPad/i.test(ua);\r\n"
"    var location = window.location;\r\n"
"    return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? ((location.protocol) + \"//\" + (location.host) + (location.pathname) + (location.search) + url) : url;\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Get the path commands to draw an svg arc\r\n"
"   * @props cx - arc center point x\r\n"
"   * @props cy - arc center point y\r\n"
"   * @props radius - arc radius\r\n"
"   * @props startAngle - arc start angle\r\n"
"   * @props endAngle - arc end angle\r\n"
"   */\r\n"
"\r\n"
"  function getSvgArcPath(cx, cy, radius, startAngle, endAngle) {\r\n"
"    var largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\r\n"
"    startAngle *= Math.PI / 180;\r\n"
"    endAngle *= Math.PI / 180;\r\n"
"    var x1 = cx + radius * Math.cos(endAngle);\r\n"
"    var y1 = cy + radius * Math.sin(endAngle);\r\n"
"    var x2 = cx + radius * Math.cos(startAngle);\r\n"
"    var y2 = cy + radius * Math.sin(startAngle);\r\n"
"    return (\"M \" + x1 + \" \" + y1 + \" A \" + radius + \" \" + radius + \" 0 \" + largeArcFlag + \" 0 \" + x2 + \" \" + y2);\r\n"
"  }\r\n"
"  /**\r\n"
"   * @desc Given a specifc (x, y) position, test if there\'s a handle there and return its index, else return null.\r\n"
"   *       This is used for components like the box and wheel which support multiple handles when multicolor is active\r\n"
"   * @props x - point x position\r\n"
"   * @props y - point y position\r\n"
"   * @props handlePositions - array of {x, y} coords for each handle\r\n"
"   */\r\n"
"\r\n"
"  function getHandleAtPoint(props, x, y, handlePositions) {\r\n"
"    for (var i = 0; i < handlePositions.length; i++) {\r\n"
"      var dX = handlePositions[i].x - x;\r\n"
"      var dY = handlePositions[i].y - y;\r\n"
"      var dist = Math.sqrt(dX * dX + dY * dY);\r\n"
"\r\n"
"      if (dist < props.handleRadius) {\r\n"
"        return i;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    return null;\r\n"
"  }\r\n"
"\r\n"
"  var iroColorPickerOptionDefaults = {\r\n"
"    width: 300,\r\n"
"    height: 300,\r\n"
"    handleRadius: 8,\r\n"
"    handleSvg: null,\r\n"
"    handleProps: {\r\n"
"      x: 0,\r\n"
"      y: 0\r\n"
"    },\r\n"
"    color: \'#fff\',\r\n"
"    colors: [],\r\n"
"    borderColor: \'#fff\',\r\n"
"    borderWidth: 0,\r\n"
"    wheelLightness: true,\r\n"
"    wheelAngle: 0,\r\n"
"    wheelDirection: \'anticlockwise\',\r\n"
"    layoutDirection: \'vertical\',\r\n"
"    sliderSize: null,\r\n"
"    sliderMargin: 12,\r\n"
"    padding: 6\r\n"
"  };\r\n"
"\r\n"
"  var SECONDARY_EVENTS = [\"mousemove\" /* MouseMove */, \"touchmove\" /* TouchMove */, \"mouseup\" /* MouseUp */, \"touchend\" /* TouchEnd */];\r\n"
"  // Base component class for iro UI components\r\n"
"  // This extends the Preact component class to allow them to react to mouse/touch input events by themselves\r\n"
"  var IroComponentBase = /*@__PURE__*/(function (Component) {\r\n"
"      function IroComponentBase(props) {\r\n"
"          Component.call(this, props);\r\n"
"          // Generate unique ID for the component\r\n"
"          // This can be used to generate unique IDs for gradients, etc\r\n"
"          this.uid = (Math.random() + 1).toString(36).substring(5);\r\n"
"      }\r\n"
"\r\n"
"      if ( Component ) IroComponentBase.__proto__ = Component;\r\n"
"      IroComponentBase.prototype = Object.create( Component && Component.prototype );\r\n"
"      IroComponentBase.prototype.constructor = IroComponentBase;\r\n"
"      IroComponentBase.prototype.render = function render (props) {\r\n"
"          var eventHandler = this.handleEvent.bind(this);\r\n"
"          var rootProps = {\r\n"
"              onMouseDown: eventHandler,\r\n"
"              // https://github.com/jaames/iro.js/issues/126\r\n"
"              // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767\r\n"
"              ontouchstart: eventHandler,\r\n"
"          };\r\n"
"          var isHorizontal = props.layoutDirection === \'horizontal\';\r\n"
"          var margin = props.margin === null ? props.sliderMargin : props.margin;\r\n"
"          var rootStyles = {\r\n"
"              overflow: \'visible\',\r\n"
"              display: isHorizontal ? \'inline-block\' : \'block\'\r\n"
"          };\r\n"
"          // first component shouldn\'t have any margin\r\n"
"          if (props.index > 0) {\r\n"
"              rootStyles[isHorizontal ? \'marginLeft\' : \'marginTop\'] = margin;\r\n"
"          }\r\n"
"          return (h(d, null, props.children(this.uid, rootProps, rootStyles)));\r\n"
"      };\r\n"
"      // More info on handleEvent:\r\n"
"      // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\r\n"
"      // TL;DR this lets us have a single point of entry for multiple events, and we can avoid callback/binding hell\r\n"
"      IroComponentBase.prototype.handleEvent = function handleEvent (e) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          var inputHandler = this.props.onInput;\r\n"
"          // Get the screen position of the component\r\n"
"          var bounds = this.base.getBoundingClientRect();\r\n"
"          // Prefect default browser action\r\n"
"          e.preventDefault();\r\n"
"          // Detect if the event is a touch event by checking if it has the `touches` property\r\n"
"          // If it is a touch event, use the first touch input\r\n"
"          var point = e.touches ? e.changedTouches[0] : e;\r\n"
"          var x = point.clientX - bounds.left;\r\n"
"          var y = point.clientY - bounds.top;\r\n"
"          switch (e.type) {\r\n"
"              case \"mousedown\" /* MouseDown */:\r\n"
"              case \"touchstart\" /* TouchStart */:\r\n"
"                  SECONDARY_EVENTS.forEach(function (event) {\r\n"
"                      document.addEventListener(event, this$1, { passive: false });\r\n"
"                  });\r\n"
"                  inputHandler(x, y, 0 /* Start */);\r\n"
"                  break;\r\n"
"              case \"mousemove\" /* MouseMove */:\r\n"
"              case \"touchmove\" /* TouchMove */:\r\n"
"                  inputHandler(x, y, 1 /* Move */);\r\n"
"                  break;\r\n"
"              case \"mouseup\" /* MouseUp */:\r\n"
"              case \"touchend\" /* TouchEnd */:\r\n"
"                  inputHandler(x, y, 2 /* End */);\r\n"
"                  SECONDARY_EVENTS.forEach(function (event) {\r\n"
"                      document.removeEventListener(event, this$1);\r\n"
"                  });\r\n"
"                  break;\r\n"
"          }\r\n"
"      };\r\n"
"\r\n"
"      return IroComponentBase;\r\n"
"  }(m));\r\n"
"\r\n"
"  function IroHandle(props) {\r\n"
"      var radius = props.r;\r\n"
"      var url = props.url;\r\n"
"      return (h(\"svg\", { className: (\"IroHandle IroHandle--\" + (props.index) + \" \" + (props.isActive ? \'IroHandle--isActive\' : \'\')), x: props.x, y: props.y, style: {\r\n"
"              overflow: \'visible\'\r\n"
"          } },\r\n"
"          url && (h(\"use\", Object.assign({ xlinkHref: resolveSvgUrl(url) }, props.props))),\r\n"
"          !url && (h(\"circle\", { r: radius, fill: \"none\", \"stroke-width\": 2, stroke: \"#000\" })),\r\n"
"          !url && (h(\"circle\", { r: radius - 2, fill: props.fill, \"stroke-width\": 2, stroke: \"#fff\" }))));\r\n"
"  }\r\n"
"  IroHandle.defaultProps = {\r\n"
"      fill: \'none\',\r\n"
"      x: 0,\r\n"
"      y: 0,\r\n"
"      r: 8,\r\n"
"      url: null,\r\n"
"      props: { x: 0, y: 0 }\r\n"
"  };\r\n"
"\r\n"
"  function IroSlider(props) {\r\n"
"      var activeIndex = props.activeIndex;\r\n"
"      var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;\r\n"
"      var ref = getSliderDimensions(props);\r\n"
"      var width = ref.width;\r\n"
"      var height = ref.height;\r\n"
"      var radius = ref.radius;\r\n"
"      var handlePos = getSliderHandlePosition(props, activeColor);\r\n"
"      var gradient = getSliderGradient(props, activeColor);\r\n"
"      var isAlpha = props.sliderType === \'alpha\';\r\n"
"      function handleInput(x, y, type) {\r\n"
"          var value = getSliderValueFromInput(props, x, y);\r\n"
"          props.parent.inputActive = true;\r\n"
"          activeColor[props.sliderType] = value;\r\n"
"          props.onInput(type);\r\n"
"      }\r\n"
"      return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"svg\", Object.assign({}, rootProps, { className: \"IroSlider\", width: width, height: height, style: rootStyles }),\r\n"
"          h(\"defs\", null,\r\n"
"              h(\"linearGradient\", Object.assign({ id: \'g\' + uid }, getSliderGradientCoords(props)), gradient.map(function (ref) {\r\n"
"                  var offset = ref[0];\r\n"
"                  var color = ref[1];\r\n"
"\r\n"
"                  return (h(\"stop\", { offset: (offset + \"%\"), \"stop-color\": color }));\r\n"
"          })),\r\n"
"              isAlpha && (h(\"pattern\", { id: \'b\' + uid, width: \"8\", height: \"8\", patternUnits: \"userSpaceOnUse\" },\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"8\", height: \"8\", fill: \"#fff\" }),\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"4\", height: \"4\", fill: \"#ccc\" }),\r\n"
"                  h(\"rect\", { x: \"4\", y: \"4\", width: \"4\", height: \"4\", fill: \"#ccc\" }))),\r\n"
"              isAlpha && (h(\"pattern\", { id: \'f\' + uid, width: \"100%\", height: \"100%\" },\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\", fill: (\"url(\" + (resolveSvgUrl(\'#b\' + uid)) + \")\") }),\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\", fill: (\"url(\" + (resolveSvgUrl(\'#g\' + uid)) + \")\") })))),\r\n"
"          h(\"rect\", { className: \"IroSliderBg\", rx: radius, ry: radius, x: props.borderWidth / 2, y: props.borderWidth / 2, width: width - props.borderWidth, height: height - props.borderWidth, \"stroke-width\": props.borderWidth, stroke: props.borderColor, fill: (\"url(\" + (resolveSvgUrl((isAlpha ? \'#f\' : \'#g\') + uid)) + \")\") }),\r\n"
"          h(IroHandle, { isActive: true, index: activeColor.index, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePos.x, y: handlePos.y }))); }));\r\n"
"  }\r\n"
"  IroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);\r\n"
"\r\n"
"  function IroBox(props) {\r\n"
"      var ref = getBoxDimensions(props);\r\n"
"      var width = ref.width;\r\n"
"      var height = ref.height;\r\n"
"      var radius = ref.radius;\r\n"
"      var colors = props.colors;\r\n"
"      var colorPicker = props.parent;\r\n"
"      var activeIndex = props.activeIndex;\r\n"
"      var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;\r\n"
"      var gradients = getBoxGradients(props, activeColor);\r\n"
"      var handlePositions = colors.map(function (color) { return getBoxHandlePosition(props, color); });\r\n"
"      function handleInput(x, y, inputType) {\r\n"
"          if (inputType === 0 /* Start */) {\r\n"
"              // getHandleAtPoint() returns the index for the handle if the point \'hits\' it, or null otherwise\r\n"
"              var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\r\n"
"              // If the input hit a handle, set it as the active handle, but don\'t update the color\r\n"
"              if (activeHandle !== null) {\r\n"
"                  colorPicker.setActiveColor(activeHandle);\r\n"
"              }\r\n"
"              // If the input didn\'t hit a handle, set the currently active handle to that position\r\n"
"              else {\r\n"
"                  colorPicker.inputActive = true;\r\n"
"                  activeColor.hsv = getBoxValueFromInput(props, x, y);\r\n"
"                  props.onInput(inputType);\r\n"
"              }\r\n"
"          }\r\n"
"          // move is fired when the user has started dragging\r\n"
"          else if (inputType === 1 /* Move */) {\r\n"
"              colorPicker.inputActive = true;\r\n"
"              activeColor.hsv = getBoxValueFromInput(props, x, y);\r\n"
"          }\r\n"
"          // let the color picker fire input:start, input:move or input:end events\r\n"
"          props.onInput(inputType);\r\n"
"      }\r\n"
"      return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"svg\", Object.assign({}, rootProps, { className: \"IroBox\", width: width, height: height, style: rootStyles }),\r\n"
"          h(\"defs\", null,\r\n"
"              h(\"linearGradient\", { id: \'s\' + uid, x1: \"0%\", y1: \"0%\", x2: \"100%\", y2: \"0%\" }, gradients[0].map(function (ref) {\r\n"
"                  var offset = ref[0];\r\n"
"                  var color = ref[1];\r\n"
"\r\n"
"                  return (h(\"stop\", { offset: (offset + \"%\"), \"stop-color\": color }));\r\n"
"          })),\r\n"
"              h(\"linearGradient\", { id: \'l\' + uid, x1: \"0%\", y1: \"0%\", x2: \"0%\", y2: \"100%\" }, gradients[1].map(function (ref) {\r\n"
"                  var offset = ref[0];\r\n"
"                  var color = ref[1];\r\n"
"\r\n"
"                  return (h(\"stop\", { offset: (offset + \"%\"), \"stop-color\": color }));\r\n"
"          })),\r\n"
"              h(\"pattern\", { id: \'f\' + uid, width: \"100%\", height: \"100%\" },\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\", fill: (\"url(\" + (resolveSvgUrl(\'#s\' + uid)) + \")\") }),\r\n"
"                  h(\"rect\", { x: \"0\", y: \"0\", width: \"100%\", height: \"100%\", fill: (\"url(\" + (resolveSvgUrl(\'#l\' + uid)) + \")\") }))),\r\n"
"          h(\"rect\", { rx: radius, ry: radius, x: props.borderWidth / 2, y: props.borderWidth / 2, width: width - props.borderWidth, height: height - props.borderWidth, \"stroke-width\": props.borderWidth, stroke: props.borderColor, fill: (\"url(\" + (resolveSvgUrl(\'#f\' + uid)) + \")\") }),\r\n"
"          colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),\r\n"
"          h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));\r\n"
"  }\r\n"
"\r\n"
"  var HUE_STEPS = Array.apply(null, { length: 360 }).map(function (_, index) { return index; });\r\n"
"  function IroWheel(props) {\r\n"
"      var ref = getWheelDimensions(props);\r\n"
"      var width = ref.width;\r\n"
"      var radius = ref.radius;\r\n"
"      var cx = ref.cx;\r\n"
"      var cy = ref.cy;\r\n"
"      var colors = props.colors;\r\n"
"      var borderWidth = props.borderWidth;\r\n"
"      var colorPicker = props.parent;\r\n"
"      var activeColor = props.color;\r\n"
"      var hsv = activeColor.hsv;\r\n"
"      var handlePositions = colors.map(function (color) { return getWheelHandlePosition(props, color); });\r\n"
"      function handleInput(x, y, inputType) {\r\n"
"          if (inputType === 0 /* Start */) {\r\n"
"              // getHandleAtPoint() returns the index for the handle if the point \'hits\' it, or null otherwise\r\n"
"              var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\r\n"
"              // If the input hit a handle, set it as the active handle, but don\'t update the color\r\n"
"              if (activeHandle !== null) {\r\n"
"                  colorPicker.setActiveColor(activeHandle);\r\n"
"              }\r\n"
"              // If the input didn\'t hit a handle, set the currently active handle to that position\r\n"
"              else {\r\n"
"                  colorPicker.inputActive = true;\r\n"
"                  activeColor.hsv = getWheelValueFromInput(props, x, y);\r\n"
"                  props.onInput(inputType);\r\n"
"              }\r\n"
"          }\r\n"
"          // move is fired when the user has started dragging\r\n"
"          else if (inputType === 1 /* Move */) {\r\n"
"              colorPicker.inputActive = true;\r\n"
"              activeColor.hsv = getWheelValueFromInput(props, x, y);\r\n"
"          }\r\n"
"          // let the color picker fire input:start, input:move or input:end events\r\n"
"          props.onInput(inputType);\r\n"
"      }\r\n"
"      return (h(IroComponentBase, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"svg\", Object.assign({}, rootProps, { className: \"IroWheel\", width: width, height: width, style: rootStyles }),\r\n"
"          h(\"defs\", null,\r\n"
"              h(\"radialGradient\", { id: uid },\r\n"
"                  h(\"stop\", { offset: \"0%\", \"stop-color\": \"#fff\" }),\r\n"
"                  h(\"stop\", { offset: \"100%\", \"stop-color\": \"#fff\", \"stop-opacity\": \"0\" }))),\r\n"
"          h(\"g\", { className: \"IroWheelHue\", \"stroke-width\": radius, fill: \"none\" }, HUE_STEPS.map(function (angle) { return (h(\"path\", { key: angle, d: getSvgArcPath(cx, cy, radius / 2, angle, angle + 1.5), stroke: (\"hsl(\" + (translateWheelAngle(props, angle)) + \", 100%, 50%)\") })); })),\r\n"
"          h(\"circle\", { className: \"IroWheelSaturation\", cx: cx, cy: cy, r: radius, fill: (\"url(\" + (resolveSvgUrl(\'#\' + uid)) + \")\") }),\r\n"
"          props.wheelLightness && (h(\"circle\", { className: \"IroWheelLightness\", cx: cx, cy: cy, r: radius, fill: \"#000\", opacity: 1 - hsv.v / 100 })),\r\n"
"          h(\"circle\", { className: \"IroWheelBorder\", cx: cx, cy: cy, r: radius, fill: \"none\", stroke: props.borderColor, \"stroke-width\": borderWidth }),\r\n"
"          colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),\r\n"
"          h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));\r\n"
"  }\r\n"
"\r\n"
"  // Turn a component into a widget\r\n"
"  // This returns a factory function that can be used to create an instance of the widget component\r\n"
"  // The first function param is a DOM element or CSS selector for the element to mount to,\r\n"
"  // The second param is for config options which are passed to the component as props\r\n"
"  // This factory function can also delay mounting the element into the DOM until the page is ready\r\n"
"  function createWidget(WidgetComponent) {\r\n"
"      var widgetFactory = function (parent, props) {\r\n"
"          var widget; // will become an instance of the widget component class\r\n"
"          var widgetRoot = document.createElement(\'div\');\r\n"
"          // Render widget into a temp DOM node\r\n"
"          I(h(WidgetComponent, Object.assign({}, {ref: function (ref) { return widget = ref; }},\r\n"
"              props)), widgetRoot);\r\n"
"          function mountWidget() {\r\n"
"              var container = parent instanceof Element ? parent : document.querySelector(parent);\r\n"
"              container.appendChild(widget.base);\r\n"
"              widget.onMount(container);\r\n"
"          }\r\n"
"          // Mount it into the DOM when the page document is ready\r\n"
"          if (document.readyState !== \'loading\') {\r\n"
"              mountWidget();\r\n"
"          }\r\n"
"          else {\r\n"
"              document.addEventListener(\'DOMContentLoaded\', mountWidget);\r\n"
"          }\r\n"
"          return widget;\r\n"
"      };\r\n"
"      // Allow the widget factory to inherit component prototype + static class methods\r\n"
"      // This makes it easier for plugin authors to extend the base widget component\r\n"
"      widgetFactory.prototype = WidgetComponent.prototype;\r\n"
"      Object.assign(widgetFactory, WidgetComponent);\r\n"
"      // Add reference to base component too\r\n"
"      widgetFactory.__component = WidgetComponent;\r\n"
"      return widgetFactory;\r\n"
"  }\r\n"
"\r\n"
"  var IroColorPicker = /*@__PURE__*/(function (Component) {\r\n"
"      function IroColorPicker(props) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          Component.call(this, props);\r\n"
"          this.colors = [];\r\n"
"          this.inputActive = false;\r\n"
"          this.events = {};\r\n"
"          this.activeEvents = {};\r\n"
"          this.deferredEvents = {};\r\n"
"          this.id = props.id;\r\n"
"          var colors = props.colors.length > 0 ? props.colors : [props.color];\r\n"
"          colors.forEach(function (colorValue) { return this$1.addColor(colorValue); });\r\n"
"          this.setActiveColor(0);\r\n"
"          // Pass all the props into the component\'s state,\r\n"
"          // Except we want to add the color object and make sure that refs aren\'t passed down to children\r\n"
"          this.state = Object.assign({}, props,\r\n"
"              {color: this.color,\r\n"
"              colors: this.colors,\r\n"
"              layout: props.layout});\r\n"
"      }\r\n"
"\r\n"
"      if ( Component ) IroColorPicker.__proto__ = Component;\r\n"
"      IroColorPicker.prototype = Object.create( Component && Component.prototype );\r\n"
"      IroColorPicker.prototype.constructor = IroColorPicker;\r\n"
"      // Plubic multicolor API\r\n"
"      /**\r\n"
"      * @desc Add a color to the color picker\r\n"
"      * @param color new color to add\r\n"
"      * @param index optional color index\r\n"
"      */\r\n"
"      IroColorPicker.prototype.addColor = function addColor (color, index) {\r\n"
"          if ( index === void 0 ) index = this.colors.length;\r\n"
"\r\n"
"          // Create a new iro.Color\r\n"
"          // Also bind it to onColorChange, so whenever the color changes it updates the color picker\r\n"
"          var newColor = new IroColor(color, this.onColorChange.bind(this));\r\n"
"          // Insert color @ the given index\r\n"
"          this.colors.splice(index, 0, newColor);\r\n"
"          // Reindex colors\r\n"
"          this.colors.forEach(function (color, index) { return color.index = index; });\r\n"
"          // Update picker state if necessary\r\n"
"          if (this.state) {\r\n"
"              this.setState({ colors: this.colors });\r\n"
"          }\r\n"
"          // Fire color init event\r\n"
"          this.deferredEmit(\'color:init\', newColor);\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Remove a color from the color picker\r\n"
"       * @param index color index\r\n"
"       */\r\n"
"      IroColorPicker.prototype.removeColor = function removeColor (index) {\r\n"
"          var color = this.colors.splice(index, 1)[0];\r\n"
"          // Destroy the color object -- this unbinds it from the color picker\r\n"
"          color.unbind();\r\n"
"          // Reindex colors\r\n"
"          this.colors.forEach(function (color, index) { return color.index = index; });\r\n"
"          // Update picker state if necessary\r\n"
"          if (this.state) {\r\n"
"              this.setState({ colors: this.colors });\r\n"
"          }\r\n"
"          // If the active color was removed, default active color to 0\r\n"
"          if (color.index === this.color.index) {\r\n"
"              this.setActiveColor(0);\r\n"
"          }\r\n"
"          // Fire color remove event\r\n"
"          this.emit(\'color:remove\', color);\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Set the currently active color\r\n"
"       * @param index color index\r\n"
"       */\r\n"
"      IroColorPicker.prototype.setActiveColor = function setActiveColor (index) {\r\n"
"          this.color = this.colors[index];\r\n"
"          if (this.state) {\r\n"
"              this.setState({ color: this.color });\r\n"
"          }\r\n"
"          // Fire color switch event\r\n"
"          this.emit(\'color:setActive\', this.color);\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Replace all of the current colorPicker colors\r\n"
"       * @param newColorValues list of new colors to add\r\n"
"       */\r\n"
"      IroColorPicker.prototype.setColors = function setColors (newColorValues) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          // Unbind color events\r\n"
"          this.colors.forEach(function (color) { return color.unbind(); });\r\n"
"          // Destroy old colors\r\n"
"          this.colors = [];\r\n"
"          // Add new colors\r\n"
"          newColorValues.forEach(function (colorValue) { return this$1.addColor(colorValue); });\r\n"
"          // Reset active color\r\n"
"          this.setActiveColor(0);\r\n"
"          this.emit(\'color:setAll\', this.colors);\r\n"
"      };\r\n"
"      // Public ColorPicker events API\r\n"
"      /**\r\n"
"       * @desc Set a callback function for an event\r\n"
"       * @param eventList event(s) to listen to\r\n"
"       * @param callback - Function called when the event is fired\r\n"
"       */\r\n"
"      IroColorPicker.prototype.on = function on (eventList, callback) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          var events = this.events;\r\n"
"          // eventList can be an eventType string or an array of eventType strings\r\n"
"          (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\r\n"
"              // Add event callback\r\n"
"              (events[eventType] || (events[eventType] = [])).push(callback);\r\n"
"              // Call deferred events\r\n"
"              // These are events that can be stored until a listener for them is added\r\n"
"              if (this$1.deferredEvents[eventType]) {\r\n"
"                  // Deffered events store an array of arguments from when the event was called\r\n"
"                  this$1.deferredEvents[eventType].forEach(function (args) {\r\n"
"                      callback.apply(null, args);\r\n"
"                  });\r\n"
"                  // Clear deferred events\r\n"
"                  this$1.deferredEvents[eventType] = [];\r\n"
"              }\r\n"
"          });\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Remove a callback function for an event added with on()\r\n"
"       * @param eventList - event(s) to listen to\r\n"
"       * @param callback - original callback function to remove\r\n"
"       */\r\n"
"      IroColorPicker.prototype.off = function off (eventList, callback) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\r\n"
"              var callbackList = this$1.events[eventType];\r\n"
"              // this.emitHook(\'event:off\', eventType, callback);\r\n"
"              if (callbackList)\r\n"
"                  { callbackList.splice(callbackList.indexOf(callback), 1); }\r\n"
"          });\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Emit an event\r\n"
"       * @param eventType event to emit\r\n"
"       */\r\n"
"      IroColorPicker.prototype.emit = function emit (eventType) {\r\n"
"          var this$1 = this;\r\n"
"          var args = [], len = arguments.length - 1;\r\n"
"          while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\r\n"
"\r\n"
"          var activeEvents = this.activeEvents;\r\n"
"          var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;\r\n"
"          // Prevent event callbacks from firing if the event is already active\r\n"
"          // This stops infinite loops if something in an event callback causes the same event to be fired again\r\n"
"          // (e.g. setting the color inside a color:change callback)\r\n"
"          if (!isEventActive) {\r\n"
"              activeEvents[eventType] = true;\r\n"
"              var callbackList = this.events[eventType] || [];\r\n"
"              callbackList.forEach(function (fn) { return fn.apply(this$1, args); });\r\n"
"              activeEvents[eventType] = false;\r\n"
"          }\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Emit an event now, or save it for when the relevent event listener is added\r\n"
"       * @param eventType - The name of the event to emit\r\n"
"       */\r\n"
"      IroColorPicker.prototype.deferredEmit = function deferredEmit (eventType) {\r\n"
"          var ref;\r\n"
"\r\n"
"          var args = [], len = arguments.length - 1;\r\n"
"          while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\r\n"
"          var deferredEvents = this.deferredEvents;\r\n"
"          (ref = this).emit.apply(ref, [ eventType ].concat( args ));\r\n"
"          (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);\r\n"
"      };\r\n"
"      // Public utility methods\r\n"
"      IroColorPicker.prototype.setOptions = function setOptions (newOptions) {\r\n"
"          this.setState(Object.assign({}, this.state, newOptions));\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Resize the color picker\r\n"
"       * @param width - new width\r\n"
"       */\r\n"
"      IroColorPicker.prototype.resize = function resize (width) {\r\n"
"          this.setOptions({ width: width });\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Reset the color picker to the initial color provided in the color picker options\r\n"
"       */\r\n"
"      IroColorPicker.prototype.reset = function reset () {\r\n"
"          this.colors.forEach(function (color) { return color.reset(); });\r\n"
"          this.setState({ colors: this.colors });\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Called by the createWidget wrapper when the element is mounted into the page\r\n"
"       * @param container - the container element for this ColorPicker instance\r\n"
"       */\r\n"
"      IroColorPicker.prototype.onMount = function onMount (container) {\r\n"
"          this.el = container;\r\n"
"          this.deferredEmit(\'mount\', this);\r\n"
"      };\r\n"
"      // Internal methods\r\n"
"      /**\r\n"
"       * @desc React to a color update\r\n"
"       * @param color - current color\r\n"
"       * @param changes - shows which h,s,v,a color channels changed\r\n"
"       */\r\n"
"      IroColorPicker.prototype.onColorChange = function onColorChange (color, changes) {\r\n"
"          this.setState({ color: this.color });\r\n"
"          if (this.inputActive) {\r\n"
"              this.inputActive = false;\r\n"
"              this.emit(\'input:change\', color, changes);\r\n"
"          }\r\n"
"          this.emit(\'color:change\', color, changes);\r\n"
"      };\r\n"
"      /**\r\n"
"       * @desc Handle input from a UI control element\r\n"
"       * @param type - event type\r\n"
"       */\r\n"
"      IroColorPicker.prototype.emitInputEvent = function emitInputEvent (type) {\r\n"
"          if (type === 0 /* Start */) {\r\n"
"              this.emit(\'input:start\', this.color);\r\n"
"          }\r\n"
"          else if (type === 1 /* Move */) {\r\n"
"              this.emit(\'input:move\', this.color);\r\n"
"          }\r\n"
"          else if (type === 2 /* End */) {\r\n"
"              this.emit(\'input:end\', this.color);\r\n"
"          }\r\n"
"      };\r\n"
"      IroColorPicker.prototype.render = function render (props, state) {\r\n"
"          var this$1 = this;\r\n"
"\r\n"
"          var layout = state.layout;\r\n"
"          // use layout shorthands\r\n"
"          if (!Array.isArray(layout)) {\r\n"
"              switch (layout) {\r\n"
"                  // TODO: implement some?\r\n"
"                  default:\r\n"
"                      layout = [\r\n"
"                          { component: IroWheel },\r\n"
"                          { component: IroSlider } ];\r\n"
"              }\r\n"
"              // add transparency slider to the layout\r\n"
"              if (state.transparency) {\r\n"
"                  layout.push({\r\n"
"                      component: IroSlider,\r\n"
"                      options: {\r\n"
"                          sliderType: \'alpha\'\r\n"
"                      }\r\n"
"                  });\r\n"
"              }\r\n"
"          }\r\n"
"          return (h(\"div\", { class: \"IroColorPicker\", id: state.id, style: {\r\n"
"                  display: state.display\r\n"
"              } }, layout.map(function (ref, componentIndex) {\r\n"
"                  var UiComponent = ref.component;\r\n"
"                  var options = ref.options;\r\n"
"\r\n"
"                  return (h(UiComponent, Object.assign({}, state, options, { ref: undefined, onInput: this$1.emitInputEvent.bind(this$1), parent: this$1, index: componentIndex })));\r\n"
"          })));\r\n"
"      };\r\n"
"\r\n"
"      return IroColorPicker;\r\n"
"  }(m));\r\n"
"  IroColorPicker.defaultProps = Object.assign({}, iroColorPickerOptionDefaults,\r\n"
"      {colors: [],\r\n"
"      display: \'block\',\r\n"
"      id: null,\r\n"
"      layout: \'default\',\r\n"
"      margin: null});\r\n"
"  var IroColorPickerWidget = createWidget(IroColorPicker);\r\n"
"\r\n"
"  var iro;\r\n"
"  (function (iro) {\r\n"
"      iro.version = \"5.2.2\"; // replaced by @rollup/plugin-replace; see rollup.config.js\r\n"
"      iro.Color = IroColor;\r\n"
"      iro.ColorPicker = IroColorPickerWidget;\r\n"
"      var ui;\r\n"
"      (function (ui) {\r\n"
"          ui.h = h;\r\n"
"          ui.ComponentBase = IroComponentBase;\r\n"
"          ui.Handle = IroHandle;\r\n"
"          ui.Slider = IroSlider;\r\n"
"          ui.Wheel = IroWheel;\r\n"
"          ui.Box = IroBox;\r\n"
"      })(ui = iro.ui || (iro.ui = {}));\r\n"
"  })(iro || (iro = {}));\r\n"
"  var iro$1 = iro;\r\n"
"\r\n"
"  return iro$1;\r\n"
"\r\n"
"}));\r\n"
